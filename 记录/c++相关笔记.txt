1.  #pragma once 与 #ifndef #endif 区别

第一点ifndef是通过判断宏是否被定义，来决定该文件是否需要被编译器包含编译，一般宏的命名方式都是 _+文件名（大写）+_H_这样的形式，如果没有define，那么就define一次好了；有一个比较关键的地方就是这个宏千万不能再别处定义，如果不小心在其他地方定义了，那就很简单了，该文件没有被包含嘛，程序会出现变量未声明等错误。通过在网上查询，有一种解释就是，编译器在执行编译的时候都需要打开这个文件，然后判断该文件是否被define 过，如果是大型工程的话，编译过程就会很花费时间。而#pragma once 不同，它是编译器来提供保证，它的判断机制是物理上的文件是否相同，而不是内容相同的两个文件，这样就省去了重复打开文件操作。所以推荐使用#pragma once 这种写法。

　　第二点就是#ifndef 是c/c++的标准，所以走到哪里都会被支持，而#pragma once 是#ifndef 之后产生的 一些老的编译器可能不被支持。不过现在做开发很少人用Turbo C  或者vc 6 了吧。所以基本不存在什么问题。

　　第三点还有一种写法就是两者可以同时使用，像这样。


1.      _cdecl
(1). 是C Declaration的缩写，表示C语言默认的函数调用方法，实际上也是C++的默认的函数调用方法。
(2). 所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。具体所示：调用方的函数调用->被调用函数的执行->被调用函数的结果返回->调用方清除调整堆栈。
(3). 被调用函数无需要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。总的来说函数的参数个数可变的(就像printf函数一样)，因为只有调用者才知道它传给被调用函数几个参数，才能在调用结束时适当地调整堆栈。
(4). 因为每个调用的地方都需要生成一段调整堆栈的代码，所以最后生成的文件较大。
 
2.      _stdcall(CALLBACK/WINAPI)
(1). 是Standard Call的缩写，要想函数按照此调用方式必须在函数名加入_stdcall，通常_ win32 api应该是_stdcall调用规则。通过VC++编写的DLL欲被其他语言编写的程序调用，应将函数的调用方式声明为_stdcall 方式，WINAPI都采用这种方式。
(2).  所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。具体所示：调用方的函数调用->被调用函数的执行->被调用方清除调整堆栈->被调用函数的结果返回。
(3).  这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retn X，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。
(4).  函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。总的来说，就是函数的参数个数不能是可变的。是从 _cdecl 修改而来,_stdcall 不支持可变参数,并且清栈由被调用者负责,其他的都一样
(5).  因为只需在被调用函数的地方生成一段调整堆栈的代码，所以最后生成的文件较小。

socket 处理客户端链接的三种模型
1：select模型
2：I/O模型
3: 完成端口模型

set:基于红黑树
hash_set: 基于哈希表

#1