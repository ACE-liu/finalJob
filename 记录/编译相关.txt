编译过程：
1: 预处理；
2：编译；
3：汇编；
4：链接；（linking）

gcc

　　认为预处理的文件是(.i)是C文件，并且设定C形式的连接；

g++

　　认为预处理的文件是(.i)是C++文件，并且设定C++形式的连接；

(1) 预处理阶段：
在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用Gcc的选项”-E”进行查看，该选项的作用是让Gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把#include包含进来的.h 文件插入到#include所在的位置，把源程序中使用到的用#define定义的宏用实际的字符串代替，我们可以用-E选项要求gcc只进行预处理而不进行后面的三个阶段，
[root@localhost Gcc]# Gcc CE hello.c Co hello.i
在此处，选项"-o"是指目标文件，".i"文件为已经过预处理的C原始程序

（2）编译阶段
接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。
编译阶段是最重要的阶段，在这个阶段GCC首先检查语法然后把由上步生成的*.i编译成*.s文件。我们可以用如下命令告诉gcc进行这一步处理，gcc -S hello.i -o hello.s，-S选项告诉gcc把hello.i编译成.s文件；

（3）汇编阶段
汇编阶段把*.s文件翻译成二进制机器指令文件*.o，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如GDB的帮助才能读懂它；
这个阶段接收.c, .i, .s的文件都没有问题。比如gcc -c hello.i -o hello.o

（4）链接阶段
在成功编译之后，就进入了链接阶段。在这里涉及到一个重要的概念：函数库。

读者可以重新查看这个小程序，在这个程序中并没有定义”printf”的函数实现，且在预编译中包含进的”stdio.h”中也只有该函数的声明，而没有定义函数的实现，那么，是在哪里实现”printf”函数的呢？最后的答案是：系统把这些函数实现都被做到名为libc.so.6的库文件中去了，在没有特别指定时，Gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf”了，而这也就是链接的作用。


$ ./configure
$ make  
$ make install

1.配置
2.确定标准库和头文件的位置
3.确定依赖关系


1:配置
1.编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做"配置"（configure）。

2.确定标准库和头文件的位置
编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时

3.确定依赖关系
编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点
（1）只有在B文件编译完成后，才开始编译A文件。
（2）当B文件发生变化时，A文件会被重新编译。
编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。



